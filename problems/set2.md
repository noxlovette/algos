Generated by Claude
## Heap Exercises

**1. Priority Task Manager**
Build a task management system where tasks have priorities (1-10). Use a max-heap to always process the highest priority task first. Implement:
- `addTask(task, priority)`
- `getNextTask()` (removes and returns highest priority)
- `peekNextTask()` (shows highest priority without removing)

**2. K-Largest Elements Finder**
Given a stream of numbers, maintain the k largest elements seen so far using a min-heap of size k. This is great for understanding why you'd use a min-heap for "largest" problems.

**3. Merge K Sorted Arrays**
Use a min-heap to efficiently merge multiple sorted arrays. Each heap node contains a value and which array/index it came from. This teaches heap operations in a realistic scenario.

**4. Hospital Emergency Room Simulator**
Patients arrive with severity scores. Use a max-heap to ensure critical patients are treated first, even if they arrive later than less critical ones.

## Hash Table Exercises

**1. Build a Simple Cache**
Implement an LRU (Least Recently Used) cache using a hash table + doubly linked list. This combines hash tables with another data structure and solves a real problem.

**2. Anagram Grouper**
Given a list of words, group anagrams together. Use a hash table where the key is the sorted characters of each word. This demonstrates hash tables for grouping/categorization.

**3. Two-Sum Problem Variations**
- Find pairs that sum to a target
- Find triplets that sum to zero
- Count pairs with given difference
These teach hash tables for lookup optimization.

**4. Word Frequency Counter with Collision Handling**
Build a hash table from scratch with:
- Custom hash function
- Collision resolution (try both chaining and open addressing)
- Dynamic resizing when load factor gets too high

**5. Substring Pattern Matching**
Implement the Rabin-Karp algorithm using rolling hash. This shows hash tables in string processing algorithms.

## Debugging Challenges

**For Heaps:** Implement heapsort and intentionally break the heap property at different steps. Fix the bugs to understand how heapify maintains the invariant.

**For Hash Tables:** Create scenarios with poor hash functions that cause many collisions, then optimize them. This teaches why good hash functions matter.

Start with the task manager and cache - they're immediately useful and clearly demonstrate why these data structures exist. Once you grasp the "why," the implementation details become much clearer.
